#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "lexer.h"
#include "stateHandlers.h"

/* Parser will be added later */
//#include "parser.h"   /* Leave this include for later implementation */

/* Define the global matrix declared as extern in lexerDef.h */

/* ==========================================================
   TRANSITION TABLE LOADER
   Reads transitionTable.xlsx - Sheet1.csv into transitionMatrix
   ========================================================== */

int transitionMatrix[67][INPUT_COUNT] = {
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {52, 65, 65, 11, 9, 65, 41, 43, 44, 2, 32, 28, 28, 16, 24, 22, 21, 38, 49, 63, 15, 18, 17, 30, 35, 65, 25, 23, 26, 45, 19, 20},
    {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},
    {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 5, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {10, 10, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {10, 12, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10},
    {14, 13, 14, 12, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14},
    {14, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 29, 29, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 31, 31, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 33, 33, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 36, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 37, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 39, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 40, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {42, 42, 42, 42, 42, 42, 41, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 46, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {47, 48, 48, 48, 48, 46, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48},
    {47, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 50, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {51, 51, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {52, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 53, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61},
    {54, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {55, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 56, 59, 59, 59, 59},
    {60, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 57, 65, 65, 65, 65, 65, 57, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {60, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {62, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {63, 63, 63, 63, 63, 63, 63, 64, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65}
};

/*
 * After compiling the static initializer we need to fill in the two new
 * input-type columns that were added for square brackets.  The original
 * matrix only provided 30 entries per row, so the last two columns (L_SQR
 * and R_SQR) will be zero-initialized.  Make them sink states by default
 * and then set the special transitions out of state 1 as requested by the
 * language spec.
 */
static void initializeBracketColumns() {
    for (int r = 0; r < 67; ++r) {
        transitionMatrix[r][L_SQR] = 65;
        transitionMatrix[r][R_SQR] = 65;
    }
    /* state 1 transitions for '[' and ']' */
    transitionMatrix[1][L_SQR] = 19;
    transitionMatrix[1][R_SQR] = 20;
}

void loadTransitionMatrix(const char *csvFile) {
    FILE *fp = fopen(csvFile, "r");
    if (!fp) {
        perror("Error opening transition table");
        exit(1);
    }

    char line[2048]; // Increased buffer size for safety
    // Skip the header line
    if (!fgets(line, sizeof(line), fp)) {
        fclose(fp);
        return;
    }

    int row = 1; // Start from state 1
    while (fgets(line, sizeof(line), fp) && row < MAX_STATES) {
        char *linePtr = line;
        char *commaPos;
        
        // 1. Skip the first column (The "State" index)
        commaPos = strchr(linePtr, ',');
        if (commaPos) linePtr = commaPos + 1;

        int col = 0;
        while (col < INPUT_COUNT) {
            commaPos = strchr(linePtr, ',');
            
            char cell[32] = {0};
            if (commaPos) {
                // Copy characters between current pointer and next comma
                strncpy(cell, linePtr, commaPos - linePtr);
                linePtr = commaPos + 1;
            } else {
                // Last column on the line
                strcpy(cell, linePtr);
            }

            // Clean trailing whitespace/newlines from cell
            char *end = cell + strlen(cell) - 1;
            while(end >= cell && (*end == '\n' || *end == '\r' || *end == ' ')) {
                *end = '\0';
                end--;
            }

            // Logic: If cell is empty, it's a sink state (65)
            if (strlen(cell) == 0) {
                transitionMatrix[row][col] = 65;
            } else {
                transitionMatrix[row][col] = atoi(cell);
            }

            col++;
            if (!commaPos) break; 
        }
        row++;
    }

    fclose(fp);
    printf("Transition Matrix loaded successfully from %s.\n", csvFile);
}
/* ===========================
   STATUS DISPLAY FUNCTION
   =========================== */

void printImplementationStatus() {
    printf("=============================================\n");
    printf("Compiler Construction Project - Status\n");
    printf("=============================================\n");

    printf("Lexical Analyzer Module: IMPLEMENTED\n");
    printf("FIRST and FOLLOW: Pending / To be implemented\n");
    printf("Predictive Parser: Pending\n");
    printf("Parse Tree Construction: Pending\n");
    printf("Error Recovery: Pending\n");

    printf("=============================================\n\n");
}


/* ===========================
   MAIN DRIVER
   =========================== */

int main(int argc, char *argv[]) {

    if (argc != 3) {
        printf("Usage: %s <sourcecodefile> <parsetreeoutfile>\n", argv[0]);
        return 1;
    }

    char *sourceFile = argv[1];
    char *parseTreeOutFile = argv[2];

    /* Initialize the accept state map (defined in lexer.c) */
    initializeAcceptStateMap();

    int option;

    printImplementationStatus();

    while (1) {
        printf("\n=========== MENU ===========\n");
        printf("0 : Exit\n");
        printf("1 : Remove comments\n");
        printf("2 : Print token list\n");
        printf("3 : Parse and print parse tree\n");
        printf("4 : Print total execution time\n");
        printf("============================\n");

        printf("Enter option: ");
        scanf("%d", &option);

        if (option == 0) {
            printf("Exiting...\n");
            break;
        }

        switch (option) {
            case 1: {
                printf("\nRemoving comments...\n");
                removeComments(sourceFile, "cleaned_output.txt");
                printf("Comment-free code printed to console.\n");
                break;
            }

            case 2: {
                printf("\nPerforming Lexical Analysis...\n");

                FILE *fp = fopen(sourceFile, "r");
                if (!fp) {
                    printf("Error opening source file.\n");
                    break;
                }

                twinBuffer *tb = initializeLexer(fp);
                tokenInfo tk;
                printf("\n%-20s %-20s %-10s\n", "LEXEME", "TOKEN", "LINE NO");
                printf("------------------------------------------------------------\n");

                while (1) {
                    tk = getNextToken(tb);
                    if (tk.token == TK_EOF)
                        break;
                    printToken(tk);
                }

                fclose(fp);
                break;
            }

            case 3: {
                printf("\nParser module not implemented yet.\n");
                break;
            }

            case 4: {
                printf("\nMeasuring execution time (Lexer + Parser)...\n");

                clock_t start_time, end_time;
                double total_CPU_time_in_seconds;

                start_time = clock();

                FILE *fp = fopen(sourceFile, "r");
                if (!fp) {
                    printf("Error opening source file.\n");
                    break;
                }

                twinBuffer *tb = initializeLexer(fp);
                tokenInfo tk;

                while (1) {
                    tk = getNextToken(tb);
                    if (tk.token == TK_EOF)
                        break;
                }
                fclose(fp);

                end_time = clock();
                total_CPU_time_in_seconds = (double)(end_time - start_time) / CLOCKS_PER_SEC;

                printf("Total CPU Time (seconds): %lf\n", total_CPU_time_in_seconds);
                break;
            }

            default:
                printf("Invalid option. Try again.\n");
        }
    }

    return 0;
}